<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Server Performance Monitor</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: #0a0e1a;
                color: #e0e0e0;
                padding: 20px;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                margin-bottom: 10px;
                color: #4caf50;
                font-size: 32px;
            }

            .subtitle {
                text-align: center;
                color: #888;
                margin-bottom: 30px;
                font-size: 14px;
            }

            .metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
                margin-bottom: 30px;
            }

            .metric-card {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
            }

            .metric-card h2 {
                font-size: 16px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .metric-value {
                font-size: 36px;
                font-weight: bold;
                color: #4caf50;
                margin-bottom: 8px;
            }

            .metric-value.warning {
                color: #ffc107;
            }

            .metric-value.danger {
                color: #f44336;
            }

            .metric-label {
                font-size: 12px;
                color: #666;
                text-transform: uppercase;
            }

            .metric-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
            }

            .metric-row:last-child {
                margin-bottom: 0;
            }

            .metric-name {
                font-size: 14px;
                color: #aaa;
            }

            .metric-stat {
                font-size: 18px;
                font-weight: bold;
                color: #4caf50;
            }

            .chart-container {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
                height: 300px;
            }

            .chart-container h3 {
                font-size: 18px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            canvas {
                width: 100% !important;
                height: calc(100% - 40px) !important;
            }

            .status-indicator {
                display: inline-block;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                margin-right: 8px;
                animation: pulse 2s infinite;
            }

            .status-indicator.good {
                background-color: #4caf50;
            }

            .status-indicator.warning {
                background-color: #ffc107;
            }

            .status-indicator.danger {
                background-color: #f44336;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                }
            }

            .endpoint-table {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
            }

            .endpoint-table h3 {
                font-size: 18px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            table {
                width: 100%;
                border-collapse: collapse;
            }

            th,
            td {
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #2a3f5f;
            }

            th {
                color: #888;
                font-weight: 600;
                text-transform: uppercase;
                font-size: 12px;
            }

            td {
                color: #e0e0e0;
            }

            tr:hover {
                background: #222938;
            }

            .refresh-info {
                text-align: center;
                color: #666;
                font-size: 12px;
                margin-top: 20px;
            }

            /* Time Range Selector Styles */
            .time-range-selector {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 30px;
                border: 1px solid #2a3f5f;
            }

            .time-range-presets {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-bottom: 15px;
            }

            .time-btn {
                padding: 10px 20px;
                background: #2a3f5f;
                color: #e0e0e0;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s;
            }

            .time-btn:hover {
                background: #3a5f8f;
            }

            .time-btn.active {
                background: #4caf50;
                color: white;
            }

            .custom-range-picker {
                background: #0f1419;
                padding: 15px;
                border-radius: 8px;
                margin-top: 15px;
                display: flex;
                gap: 15px;
                align-items: center;
                flex-wrap: wrap;
            }

            .custom-range-picker label {
                color: #aaa;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .custom-range-picker input {
                background: #1a1f2e;
                border: 1px solid #2a3f5f;
                color: #e0e0e0;
                padding: 8px;
                border-radius: 4px;
                font-size: 13px;
            }

            .apply-btn {
                padding: 8px 20px;
                background: #4caf50;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }

            .apply-btn:hover {
                background: #45a049;
            }

            .range-info {
                display: flex;
                justify-content: space-between;
                color: #888;
                font-size: 13px;
                margin-top: 10px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Server Performance Monitor</h1>
            <p class="subtitle">
                Real-time performance metrics and system monitoring
            </p>

            <!-- Time Range Selector -->
            <div class="time-range-selector">
                <div class="time-range-presets">
                    <button class="time-btn live-toggle active" id="liveToggle">
                        ðŸ”´ Live
                    </button>
                    <div
                        style="
                            width: 2px;
                            height: 30px;
                            background: #2a3f5f;
                            margin: 0 10px;
                        "
                    ></div>
                    <button class="time-btn active" data-range="1m">
                        1 Min
                    </button>
                    <button class="time-btn" data-range="5m">5 Min</button>
                    <button class="time-btn" data-range="1h">1 Hour</button>
                    <button class="time-btn" data-range="12h">12 Hours</button>
                    <button class="time-btn" data-range="24h">24 Hours</button>
                    <button class="time-btn" data-range="48h">48 Hours</button>
                    <button class="time-btn" data-range="custom">
                        Custom Range
                    </button>
                </div>
                <div
                    class="custom-range-picker"
                    id="customRangePicker"
                    style="display: none"
                >
                    <label
                        >From: <input type="datetime-local" id="startTime"
                    /></label>
                    <label
                        >To: <input type="datetime-local" id="endTime"
                    /></label>
                    <button class="apply-btn" id="applyCustomRange">
                        Apply
                    </button>
                </div>
                <div class="range-info">
                    <span id="dataPoints"></span>
                </div>
            </div>

            <!-- Key Metrics Grid -->
            <div class="metrics-grid">
                <!-- Game Loop Performance -->
                <div class="metric-card">
                    <h2>Game Loop</h2>
                    <div class="metric-value" id="tick-time">0.00</div>
                    <div class="metric-label">Avg Tick Time (ms)</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Ticks/Sec</span>
                        <span class="metric-stat" id="ticks-per-sec">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Max Tick</span>
                        <span class="metric-stat" id="max-tick-time"
                            >0.00ms</span
                        >
                    </div>
                </div>

                <!-- System Resources -->
                <div class="metric-card">
                    <h2>System Resources</h2>
                    <div class="metric-value" id="memory-usage">0</div>
                    <div class="metric-label">Memory Usage (MB)</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">CPU Usage</span>
                        <span class="metric-stat" id="cpu-usage">0%</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Uptime</span>
                        <span class="metric-stat" id="uptime">0s</span>
                    </div>
                </div>

                <!-- Game State -->
                <div class="metric-card">
                    <h2>Game State</h2>
                    <div class="metric-value" id="total-players">0</div>
                    <div class="metric-label">Total Players</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Humans</span>
                        <span class="metric-stat" id="human-players">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Bots</span>
                        <span class="metric-stat" id="bot-count">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Projectiles</span>
                        <span class="metric-stat" id="projectile-count">0</span>
                    </div>
                </div>

                <!-- Network -->
                <div class="metric-card">
                    <h2>Network</h2>
                    <div class="metric-value" id="messages-per-sec">0</div>
                    <div class="metric-label">Messages/Sec</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Connections</span>
                        <span class="metric-stat" id="active-connections"
                            >0</span
                        >
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Bytes/Sec</span>
                        <span class="metric-stat" id="bytes-per-sec">0</span>
                    </div>
                </div>
            </div>

            <!-- Charts -->
            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Tick Time History
                </h3>
                <canvas id="tick-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Memory Usage Over
                    Time
                </h3>
                <canvas id="memory-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Player Count Over
                    Time
                </h3>
                <canvas id="player-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Ticks Per Second
                </h3>
                <canvas id="ticks-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Game Statistics
                </h3>
                <canvas id="game-stats-chart"></canvas>
            </div>

            <!-- API Endpoints Table -->
            <div class="endpoint-table">
                <h3>API Endpoint Performance</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Endpoint</th>
                            <th>Requests</th>
                            <th>Avg Time (ms)</th>
                            <th>Errors</th>
                        </tr>
                    </thead>
                    <tbody id="endpoint-tbody">
                        <tr>
                            <td
                                colspan="4"
                                style="text-align: center; color: #666"
                            >
                                Loading...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p class="refresh-info">Auto-refreshing every 1 second</p>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
        <script src="/socket.io/socket.io.js"></script>
        <script>
            // Chart configurations
            const chartConfig = {
                type: "line",
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 750,
                        easing: "easeInOutQuart",
                    },
                    plugins: {
                        legend: {
                            display: false,
                        },
                    },
                    scales: {
                        x: {
                            display: true,
                            type: 'time',
                            time: {
                                unit: 'second',
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM dd, HH:mm:ss'
                            },
                            grid: {
                                color: "#2a3f5f",
                            },
                            ticks: {
                                color: "#888",
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 10
                            },
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: "#2a3f5f",
                            },
                            ticks: {
                                color: "#888",
                            },
                        },
                    },
                    elements: {
                        line: {
                            tension: 0.4,
                        },
                        point: {
                            radius: 0,
                        },
                    },
                },
            };

            // Initialize charts
            const tickChart = new Chart(document.getElementById("tick-chart"), {
                ...chartConfig,
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Tick Time (ms)",
                            data: [],
                            borderColor: "#4CAF50",
                            backgroundColor: "rgba(76, 175, 80, 0.1)",
                            fill: true,
                        },
                    ],
                },
            });

            const memoryChart = new Chart(
                document.getElementById("memory-chart"),
                {
                    ...chartConfig,
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Memory (MB)",
                                data: [],
                                borderColor: "#2196F3",
                                backgroundColor: "rgba(33, 150, 243, 0.1)",
                                fill: true,
                            },
                        ],
                    },
                },
            );

            const playerChart = new Chart(
                document.getElementById("player-chart"),
                {
                    ...chartConfig,
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Players",
                                data: [],
                                borderColor: "#FF9800",
                                backgroundColor: "rgba(255, 152, 0, 0.1)",
                                fill: true,
                            },
                        ],
                    },
                },
            );

            const ticksChart = new Chart(
                document.getElementById("ticks-chart"),
                {
                    ...chartConfig,
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Ticks/Sec",
                                data: [],
                                borderColor: "#9C27B0",
                                backgroundColor: "rgba(156, 39, 176, 0.1)",
                                fill: true,
                            },
                        ],
                    },
                },
            );

            const gameStatsChart = new Chart(
                document.getElementById("game-stats-chart"),
                {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Damage/Sec",
                                data: [],
                                borderColor: "#F44336",
                                backgroundColor: "rgba(244, 67, 54, 0.1)",
                                fill: false,
                                yAxisID: "y",
                                tension: 0.4,
                                pointRadius: 0,
                            },
                            {
                                label: "Projectile Count",
                                data: [],
                                borderColor: "#FF9800",
                                backgroundColor: "rgba(255, 152, 0, 0.1)",
                                fill: false,
                                yAxisID: "y1",
                                tension: 0.4,
                                pointRadius: 0,
                            },
                            {
                                label: "Deaths/Sec",
                                data: [],
                                borderColor: "#9C27B0",
                                backgroundColor: "rgba(156, 39, 176, 0.1)",
                                fill: false,
                                yAxisID: "y1",
                                tension: 0.4,
                                pointRadius: 0,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: {
                            duration: 750,
                            easing: "easeInOutQuart",
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: "#888",
                                },
                            },
                        },
                        scales: {
                            x: {
                                display: true,
                                type: 'time',
                                time: {
                                    unit: 'second',
                                    displayFormats: {
                                        second: 'HH:mm:ss',
                                        minute: 'HH:mm',
                                        hour: 'HH:mm'
                                    },
                                    tooltipFormat: 'MMM dd, HH:mm:ss'
                                },
                                grid: {
                                    color: "#2a3f5f",
                                },
                                ticks: {
                                    color: "#888",
                                    maxRotation: 45,
                                    minRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 10
                                },
                            },
                            y: {
                                type: "linear",
                                display: true,
                                position: "left",
                                title: {
                                    display: true,
                                    text: "Damage/Sec",
                                    color: "#F44336",
                                },
                                grid: {
                                    color: "#2a3f5f",
                                },
                                ticks: {
                                    color: "#F44336",
                                },
                            },
                            y1: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: {
                                    display: true,
                                    text: "Count",
                                    color: "#FF9800",
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                ticks: {
                                    color: "#FF9800",
                                },
                            },
                        },
                        elements: {
                            point: {
                                radius: 0,
                            },
                        },
                    },
                },
            );

            // Utility functions
            function formatBytes(bytes) {
                if (bytes === 0) return "0 B";
                const k = 1024;
                const sizes = ["B", "KB", "MB", "GB"];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return (
                    Math.round((bytes / Math.pow(k, i)) * 100) / 100 +
                    " " +
                    sizes[i]
                );
            }

            function formatUptime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }

            function updateMetricValue(id, value, thresholds) {
                const element = document.getElementById(id);
                if (!element) {
                    console.warn(`Element with id '${id}' not found`);
                    return;
                }

                element.textContent = value;

                // Update color based on thresholds
                if (thresholds) {
                    element.classList.remove("warning", "danger");
                    if (
                        thresholds.danger &&
                        parseFloat(value) >= thresholds.danger
                    ) {
                        element.classList.add("danger");
                    } else if (
                        thresholds.warning &&
                        parseFloat(value) >= thresholds.warning
                    ) {
                        element.classList.add("warning");
                    }
                }
            }

            // Fetch and update metrics (fallback polling - not used when WebSocket works)
            async function updateMetrics() {
                try {
                    const response = await fetch("/api/metrics");
                    const metrics = await response.json();

                    // Use the same processing function as WebSocket
                    processMetricsUpdate(metrics);
                } catch (error) {
                    console.error("Failed to fetch metrics:", error);
                }
            }

            // Connect to WebSocket for real-time updates
            const socket = io("/performance", {
                transports: ["websocket", "polling"],
                upgrade: true,
            });

            socket.on("connect", () => {
                console.log("Connected to performance metrics stream");
                document.querySelector(".subtitle").textContent =
                    "Real-time performance metrics (WebSocket connected)";
            });

            socket.on("connect_error", (error) => {
                console.error("WebSocket connection error:", error);
            });

            socket.on("disconnect", (reason) => {
                console.log(
                    "Disconnected from performance metrics stream:",
                    reason,
                );
                document.querySelector(".subtitle").textContent =
                    "Real-time performance metrics (WebSocket disconnected)";
            });

            // Process metrics updates (used by both WebSocket and initial load)
            function processMetricsUpdate(metrics) {
                // In custom range mode, don't update at all (static view)
                if (isCustomRange) return;

                // Update game loop metrics
                updateMetricValue(
                    "tick-time",
                    (metrics.gameLoop.avgTickTime || 0).toFixed(2),
                    {
                        warning: 16.67,
                        danger: 20,
                    },
                );
                updateMetricValue(
                    "ticks-per-sec",
                    metrics.gameLoop.ticksPerSecond || 0,
                );
                updateMetricValue(
                    "max-tick-time",
                    (metrics.gameLoop.maxTickTime || 0).toFixed(2) + "ms",
                );

                // Update system metrics
                updateMetricValue(
                    "memory-usage",
                    metrics.system.memoryUsageMB,
                    {
                        warning: 500,
                        danger: 1000,
                    },
                );
                updateMetricValue("cpu-usage", metrics.system.cpuUsage + "%", {
                    warning: 70,
                    danger: 90,
                });
                updateMetricValue(
                    "uptime",
                    formatUptime(metrics.system.uptime),
                );

                // Update game state metrics
                updateMetricValue(
                    "total-players",
                    metrics.gameState.playerCount + metrics.gameState.botCount,
                );
                updateMetricValue(
                    "human-players",
                    metrics.gameState.playerCount,
                );
                updateMetricValue("bot-count", metrics.gameState.botCount);
                updateMetricValue(
                    "projectile-count",
                    metrics.gameState.projectileCount,
                );

                // Update network metrics
                updateMetricValue(
                    "messages-per-sec",
                    metrics.network.messagesPerSecond,
                );
                updateMetricValue(
                    "active-connections",
                    metrics.network.activeConnections,
                );
                updateMetricValue(
                    "bytes-per-sec",
                    formatBytes(metrics.network.bytesPerSecond),
                );

                // Update charts
                const now = Date.now();

                // Only append new data if live updates are enabled and not in custom range mode
                if (!isLiveMode || isCustomRange) return;

                // Append new data to charts
                tickChart.data.labels.push(now);
                tickChart.data.datasets[0].data.push(
                    metrics.gameLoop.avgTickTime ?? null,
                );

                memoryChart.data.labels.push(now);
                memoryChart.data.datasets[0].data.push(
                    metrics.system.memoryUsageMB ?? null,
                );

                playerChart.data.labels.push(now);
                const playerCount = metrics.gameState.playerCount ?? null;
                const botCount = metrics.gameState.botCount ?? null;
                playerChart.data.datasets[0].data.push(
                    playerCount !== null && botCount !== null
                        ? playerCount + botCount
                        : null,
                );

                ticksChart.data.labels.push(now);
                ticksChart.data.datasets[0].data.push(
                    metrics.gameLoop.ticksPerSecond ?? null,
                );

                gameStatsChart.data.labels.push(now);
                const damagePerSec = metrics.gameStats?.damagePerSecond || 0;
                const projCount = metrics.gameState?.projectileCount || 0;
                const deathsPerSec = metrics.gameStats?.deathsPerSecond || 0;

                gameStatsChart.data.datasets[0].data.push(damagePerSec);
                gameStatsChart.data.datasets[1].data.push(projCount);
                gameStatsChart.data.datasets[2].data.push(deathsPerSec);

                // Debug logging for game stats
                if (damagePerSec > 0 || projCount > 0 || deathsPerSec > 0) {
                    console.log("Game stats update:", {
                        damagePerSec,
                        projCount,
                        deathsPerSec,
                        dataPoints: gameStatsChart.data.labels.length,
                    });
                }

                // Filter out old data points based on time window
                filterOldDataPoints();

                // Update all charts with smooth animation
                tickChart.update("active");
                memoryChart.update("active");
                playerChart.update("active");
                ticksChart.update("active");
                gameStatsChart.update("active");

                // Update API endpoint table
                const tbody = document.getElementById("endpoint-tbody");
                tbody.innerHTML = "";

                const endpoints = Object.entries(metrics.api.endpointStats);
                if (endpoints.length === 0) {
                    tbody.innerHTML =
                        '<tr><td colspan="4" style="text-align: center; color: #666;">No API requests yet</td></tr>';
                } else {
                    endpoints.forEach(([endpoint, stats]) => {
                        const row = document.createElement("tr");
                        row.innerHTML = `
                        <td>${endpoint}</td>
                        <td>${stats.count}</td>
                        <td>${stats.avgTime.toFixed(2)}</td>
                        <td style="color: ${stats.errors > 0 ? "#F44336" : "#4CAF50"}">${stats.errors}</td>
                    `;
                        tbody.appendChild(row);
                    });
                }
            }

            // WebSocket metrics handler
            socket.on("metrics", processMetricsUpdate);

            // Fallback to polling if WebSocket fails
            socket.on("connect_error", () => {
                console.log("WebSocket failed, falling back to polling");
                setInterval(updateMetrics, 1000);
            });

            // Time Range Selection
            let currentTimeRange = "1m"; // Default rolling window
            let customStart = null;
            let customEnd = null;
            let isLiveMode = true; // Whether to receive live updates
            let historicalRefreshInterval = null;
            let isCustomRange = false;

            // Convert range string to milliseconds
            function rangeToMs(range) {
                const units = {
                    "1m": 1 * 60 * 1000,
                    "5m": 5 * 60 * 1000,
                    "1h": 1 * 60 * 60 * 1000,
                    "12h": 12 * 60 * 60 * 1000,
                    "24h": 24 * 60 * 60 * 1000,
                    "48h": 48 * 60 * 60 * 1000,
                };
                return units[range] || units["24h"];
            }

            // Update historical data
            async function updateHistoricalData() {
                try {
                    let url;
                    if (
                        currentTimeRange === "custom" &&
                        customStart &&
                        customEnd
                    ) {
                        // Custom range query
                        const start = new Date(customStart).getTime();
                        const end = new Date(customEnd).getTime();
                        url = `/api/metrics/history?start=${start}&end=${end}`;
                    } else {
                        // Preset range - get rolling window
                        const hours =
                            rangeToMs(currentTimeRange) / (60 * 60 * 1000);
                        url = `/api/metrics/history?hours=${hours}`;
                    }

                    const response = await fetch(url);
                    const result = await response.json();

                    // Update data points display
                    document.getElementById("dataPoints").textContent =
                        `${result.count} data points`;

                    console.log(
                        `Loaded ${result.count} historical data points`,
                    );

                    // Calculate aggregates and update dashboard
                    const aggregates = calculateAggregates(result.data);
                    if (aggregates) {
                        updateDashboardWithAggregates(aggregates);
                    }

                    // Update charts with historical data
                    updateChartsWithHistoricalData(result.data);
                } catch (error) {
                    console.error("Failed to load historical data:", error);
                }
            }

            // Filter out data points older than the current time window
            function filterOldDataPoints() {
                if (!isLiveMode || isCustomRange) return; // Only filter in live mode, not in custom range

                const now = Date.now();
                const windowMs = rangeToMs(currentTimeRange);
                const cutoffTime = now - windowMs;

                // Filter tick chart
                while (
                    tickChart.data.labels.length > 0 &&
                    tickChart.data.labels[0] < cutoffTime
                ) {
                    tickChart.data.labels.shift();
                    tickChart.data.datasets[0].data.shift();
                }

                // Filter memory chart
                while (
                    memoryChart.data.labels.length > 0 &&
                    memoryChart.data.labels[0] < cutoffTime
                ) {
                    memoryChart.data.labels.shift();
                    memoryChart.data.datasets[0].data.shift();
                }

                // Filter player chart
                while (
                    playerChart.data.labels.length > 0 &&
                    playerChart.data.labels[0] < cutoffTime
                ) {
                    playerChart.data.labels.shift();
                    playerChart.data.datasets[0].data.shift();
                }

                // Filter ticks per second chart
                while (
                    ticksChart.data.labels.length > 0 &&
                    ticksChart.data.labels[0] < cutoffTime
                ) {
                    ticksChart.data.labels.shift();
                    ticksChart.data.datasets[0].data.shift();
                }

                // Filter game stats chart
                while (
                    gameStatsChart.data.labels.length > 0 &&
                    gameStatsChart.data.labels[0] < cutoffTime
                ) {
                    gameStatsChart.data.labels.shift();
                    gameStatsChart.data.datasets[0].data.shift();
                    gameStatsChart.data.datasets[1].data.shift();
                    gameStatsChart.data.datasets[2].data.shift();
                }
            }

            // Update charts with historical data
            function updateChartsWithHistoricalData(data) {
                if (!data || data.length === 0) {
                    console.log("No historical data to display");
                    // Clear charts if no data
                    tickChart.data.labels = [];
                    tickChart.data.datasets[0].data = [];
                    memoryChart.data.labels = [];
                    memoryChart.data.datasets[0].data = [];
                    playerChart.data.labels = [];
                    playerChart.data.datasets[0].data = [];
                    ticksChart.data.labels = [];
                    ticksChart.data.datasets[0].data = [];
                    gameStatsChart.data.labels = [];
                    gameStatsChart.data.datasets[0].data = [];
                    gameStatsChart.data.datasets[1].data = [];
                    gameStatsChart.data.datasets[2].data = [];

                    tickChart.update();
                    memoryChart.update();
                    playerChart.update();
                    ticksChart.update();
                    gameStatsChart.update();
                    return;
                }

                console.log(
                    `Updating charts with ${data.length} historical data points`,
                );

                // Clear existing chart data
                tickChart.data.labels = [];
                tickChart.data.datasets[0].data = [];
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                playerChart.data.labels = [];
                playerChart.data.datasets[0].data = [];
                ticksChart.data.labels = [];
                ticksChart.data.datasets[0].data = [];
                gameStatsChart.data.labels = [];
                gameStatsChart.data.datasets[0].data = [];
                gameStatsChart.data.datasets[1].data = [];
                gameStatsChart.data.datasets[2].data = [];

                // Populate charts with historical data
                // Store actual timestamps (in ms) as labels for filtering later
                data.forEach((snapshot, index) => {
                    const timestamp = snapshot.timestamp;

                    // Tick time chart
                    tickChart.data.labels.push(timestamp);
                    tickChart.data.datasets[0].data.push(
                        snapshot.avg_tick_time || 0,
                    );

                    // Memory chart
                    memoryChart.data.labels.push(timestamp);
                    memoryChart.data.datasets[0].data.push(
                        snapshot.memory_usage_mb || 0,
                    );

                    // Player chart
                    playerChart.data.labels.push(timestamp);
                    playerChart.data.datasets[0].data.push(
                        (snapshot.player_count || 0) +
                            (snapshot.bot_count || 0),
                    );

                    // Ticks per second chart
                    ticksChart.data.labels.push(timestamp);
                    ticksChart.data.datasets[0].data.push(
                        snapshot.ticks_per_second || 0,
                    );

                    // Game stats chart
                    gameStatsChart.data.labels.push(timestamp);
                    gameStatsChart.data.datasets[0].data.push(
                        snapshot.damage_per_second || 0,
                    );
                    gameStatsChart.data.datasets[1].data.push(
                        snapshot.projectile_count || 0,
                    );
                    gameStatsChart.data.datasets[2].data.push(
                        snapshot.deaths_per_second || 0,
                    );

                    // Debug: log first data point
                    if (index === 0) {
                        console.log("First game stats data point:", {
                            damage_per_second: snapshot.damage_per_second,
                            projectile_count: snapshot.projectile_count,
                            deaths_per_second: snapshot.deaths_per_second,
                        });
                    }
                });

                // Update all charts with animation disabled for smooth transition
                tickChart.update('none');
                memoryChart.update('none');
                playerChart.update('none');
                ticksChart.update('none');
                gameStatsChart.update('none');

                console.log("Charts updated with historical data, ready for live updates");
            }

            // Calculate aggregated metrics from historical data
            function calculateAggregates(data) {
                if (!data || data.length === 0) {
                    return null;
                }

                const aggregate = {
                    tickTime: { avg: 0, min: Infinity, max: -Infinity, p95: 0 },
                    memory: { avg: 0, min: Infinity, max: -Infinity },
                    cpu: { avg: 0, min: Infinity, max: -Infinity },
                    players: { avg: 0, min: Infinity, max: -Infinity },
                    api: { avgResponseTime: 0 },
                    health: { avg: 0 },
                };

                let totalTickTime = 0;
                let tickCount = 0;
                const tickTimes = [];

                data.forEach((snapshot) => {
                    // Game Loop
                    if (snapshot.avg_tick_time != null) {
                        totalTickTime += snapshot.avg_tick_time;
                        tickCount++;
                        if (snapshot.tick_p95)
                            tickTimes.push(snapshot.tick_p95);
                        aggregate.tickTime.min = Math.min(
                            aggregate.tickTime.min,
                            snapshot.avg_tick_time,
                        );
                        aggregate.tickTime.max = Math.max(
                            aggregate.tickTime.max,
                            snapshot.max_tick_time || 0,
                        );
                    }

                    // Memory
                    if (snapshot.memory_usage_mb != null) {
                        aggregate.memory.avg += snapshot.memory_usage_mb;
                        aggregate.memory.min = Math.min(
                            aggregate.memory.min,
                            snapshot.memory_usage_mb,
                        );
                        aggregate.memory.max = Math.max(
                            aggregate.memory.max,
                            snapshot.memory_usage_mb,
                        );
                    }

                    // CPU
                    if (snapshot.cpu_usage != null) {
                        aggregate.cpu.avg += snapshot.cpu_usage;
                        aggregate.cpu.min = Math.min(
                            aggregate.cpu.min,
                            snapshot.cpu_usage,
                        );
                        aggregate.cpu.max = Math.max(
                            aggregate.cpu.max,
                            snapshot.cpu_usage,
                        );
                    }

                    // Players
                    const totalPlayers =
                        (snapshot.player_count || 0) +
                        (snapshot.bot_count || 0);
                    aggregate.players.avg += totalPlayers;
                    aggregate.players.min = Math.min(
                        aggregate.players.min,
                        totalPlayers,
                    );
                    aggregate.players.max = Math.max(
                        aggregate.players.max,
                        totalPlayers,
                    );

                    // API
                    if (snapshot.api_avg_response_time) {
                        aggregate.api.avgResponseTime +=
                            snapshot.api_avg_response_time;
                    }

                    // Health
                    if (snapshot.overall_health != null) {
                        aggregate.health.avg += snapshot.overall_health;
                    }
                });

                const count = data.length;
                aggregate.tickTime.avg =
                    tickCount > 0 ? (totalTickTime / tickCount).toFixed(2) : 0;
                aggregate.tickTime.p95 =
                    tickTimes.length > 0
                        ? tickTimes.sort((a, b) => a - b)[
                              Math.floor(tickTimes.length * 0.95)
                          ]
                        : 0;
                aggregate.memory.avg = (aggregate.memory.avg / count).toFixed(
                    0,
                );
                aggregate.cpu.avg = (aggregate.cpu.avg / count).toFixed(1);
                aggregate.players.avg = (aggregate.players.avg / count).toFixed(
                    1,
                );
                aggregate.api.avgResponseTime = (
                    aggregate.api.avgResponseTime / count
                ).toFixed(2);
                aggregate.health.avg = (aggregate.health.avg / count).toFixed(
                    1,
                );

                return aggregate;
            }

            // Update dashboard with aggregated data
            function updateDashboardWithAggregates(aggregates) {
                if (!aggregates) return;

                // Update Game Loop metrics
                updateMetricValue("tick-time", aggregates.tickTime.avg, {
                    warning: 16.67,
                    danger: 20,
                });
                updateMetricValue(
                    "max-tick-time",
                    aggregates.tickTime.max.toFixed(2) + "ms",
                );

                // Update System metrics
                updateMetricValue("memory-usage", aggregates.memory.avg, {
                    warning: 500,
                    danger: 1000,
                });
                updateMetricValue("cpu-usage", aggregates.cpu.avg + "%", {
                    warning: 70,
                    danger: 90,
                });

                // Update player count
                updateMetricValue(
                    "total-players",
                    Math.round(aggregates.players.avg),
                );

                console.log(
                    "Dashboard updated with aggregated data:",
                    aggregates,
                );
            }

            // Handle live toggle button
            document
                .getElementById("liveToggle")
                .addEventListener("click", function () {
                    isLiveMode = !isLiveMode;

                    if (isLiveMode) {
                        this.classList.add("active");
                        this.innerHTML = "ðŸ”´ Live";
                        console.log("Live updates enabled");
                    } else {
                        this.classList.remove("active");
                        this.innerHTML = "â¸ï¸ Paused";
                        console.log("Live updates paused");
                    }
                });

            // Handle time range button clicks (excluding live toggle)
            document
                .querySelectorAll(".time-btn[data-range]")
                .forEach((btn) => {
                    btn.addEventListener("click", function () {
                        const range = this.getAttribute("data-range");

                        // Remove active class from all time range buttons (not live toggle)
                        document
                            .querySelectorAll(".time-btn[data-range]")
                            .forEach((b) => b.classList.remove("active"));

                        // Add active class to clicked button
                        this.classList.add("active");

                        currentTimeRange = range;
                        isCustomRange = false;

                        // Stop any existing refresh interval
                        if (historicalRefreshInterval) {
                            clearInterval(historicalRefreshInterval);
                            historicalRefreshInterval = null;
                        }

                        // Show/hide custom range picker
                        const customPicker =
                            document.getElementById("customRangePicker");
                        if (range === "custom") {
                            customPicker.style.display = "flex";

                            // Set default values to last 24 hours
                            const now = new Date();
                            const yesterday = new Date(
                                now.getTime() - 24 * 60 * 60 * 1000,
                            );

                            document.getElementById("endTime").value = now
                                .toISOString()
                                .slice(0, 16);
                            document.getElementById("startTime").value =
                                yesterday.toISOString().slice(0, 16);
                        } else {
                            customPicker.style.display = "none";

                            // Reset custom range button text
                            document.querySelector(
                                '[data-range="custom"]',
                            ).textContent = "Custom Range";

                            // Load historical data
                            updateHistoricalData();
                        }
                    });
                });

            // Handle custom range apply button
            document
                .getElementById("applyCustomRange")
                .addEventListener("click", function () {
                    customStart = document.getElementById("startTime").value;
                    customEnd = document.getElementById("endTime").value;

                    if (!customStart || !customEnd) {
                        alert("Please select both start and end times");
                        return;
                    }

                    const start = new Date(customStart);
                    const end = new Date(customEnd);

                    if (start >= end) {
                        alert("Start time must be before end time");
                        return;
                    }

                    // Custom range is static - stop auto-refresh
                    isLiveMode = false;
                    isCustomRange = true;
                    if (historicalRefreshInterval) {
                        clearInterval(historicalRefreshInterval);
                        historicalRefreshInterval = null;
                    }

                    // Update custom range button text
                    const customBtn = document.querySelector(
                        '[data-range="custom"]',
                    );
                    customBtn.textContent = `${start.toLocaleDateString()} ${start.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })} - ${end.toLocaleDateString()} ${end.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })} (Custom)`;

                    // Load historical data for custom range (static, no auto-refresh)
                    updateHistoricalData();
                });

            // Load initial historical data for the default time range (1m)
            updateHistoricalData();

            // Fetch initial metrics immediately on page load to avoid delay
            async function loadInitialMetrics() {
                try {
                    console.log("Fetching initial metrics...");
                    const startTime = Date.now();
                    const response = await fetch("/api/metrics");
                    const metrics = await response.json();
                    const loadTime = Date.now() - startTime;
                    console.log(
                        `Initial metrics loaded via HTTP in ${loadTime}ms`,
                        metrics,
                    );

                    // Process the metrics immediately
                    processMetricsUpdate(metrics);
                } catch (error) {
                    console.error("Failed to load initial metrics:", error);
                }
            }

            // Call this immediately
            loadInitialMetrics();
        </script>
    </body>
</html>
