<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Server Performance Monitor</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: #0a0e1a;
                color: #e0e0e0;
                padding: 20px;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                margin-bottom: 10px;
                color: #4caf50;
                font-size: 32px;
            }

            .subtitle {
                text-align: center;
                color: #888;
                margin-bottom: 30px;
                font-size: 14px;
            }

            .metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
                margin-bottom: 30px;
            }

            .metric-card {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
            }

            .metric-card h2 {
                font-size: 16px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .metric-value {
                font-size: 36px;
                font-weight: bold;
                color: #4caf50;
                margin-bottom: 8px;
            }

            .metric-value.warning {
                color: #ffc107;
            }

            .metric-value.danger {
                color: #f44336;
            }

            .metric-label {
                font-size: 12px;
                color: #666;
                text-transform: uppercase;
            }

            .metric-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
            }

            .metric-row:last-child {
                margin-bottom: 0;
            }

            .metric-name {
                font-size: 14px;
                color: #aaa;
            }

            .metric-stat {
                font-size: 18px;
                font-weight: bold;
                color: #4caf50;
            }

            .chart-container {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
                height: 300px;
            }

            .chart-container h3 {
                font-size: 18px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            canvas {
                width: 100% !important;
                height: calc(100% - 40px) !important;
            }

            .status-indicator {
                display: inline-block;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                margin-right: 8px;
                animation: pulse 2s infinite;
            }

            .status-indicator.good {
                background-color: #4caf50;
            }

            .status-indicator.warning {
                background-color: #ffc107;
            }

            .status-indicator.danger {
                background-color: #f44336;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                }
            }

            .endpoint-table {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                border: 1px solid #2a3f5f;
            }

            .endpoint-table h3 {
                font-size: 18px;
                color: #888;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            table {
                width: 100%;
                border-collapse: collapse;
            }

            th,
            td {
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #2a3f5f;
            }

            th {
                color: #888;
                font-weight: 600;
                text-transform: uppercase;
                font-size: 12px;
            }

            td {
                color: #e0e0e0;
            }

            tr:hover {
                background: #222938;
            }

            .refresh-info {
                text-align: center;
                color: #666;
                font-size: 12px;
                margin-top: 20px;
            }

            /* Time Range Selector Styles */
            .time-range-selector {
                background: #1a1f2e;
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 30px;
                border: 1px solid #2a3f5f;
            }

            .time-range-presets {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-bottom: 15px;
            }

            .time-btn {
                padding: 10px 20px;
                background: #2a3f5f;
                color: #e0e0e0;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s;
            }

            .time-btn:hover {
                background: #3a5f8f;
            }

            .time-btn.active {
                background: #4caf50;
                color: white;
            }

            .custom-range-picker {
                background: #0f1419;
                padding: 15px;
                border-radius: 8px;
                margin-top: 15px;
                display: flex;
                gap: 15px;
                align-items: center;
                flex-wrap: wrap;
            }

            .custom-range-picker label {
                color: #aaa;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .custom-range-picker input {
                background: #1a1f2e;
                border: 1px solid #2a3f5f;
                color: #e0e0e0;
                padding: 8px;
                border-radius: 4px;
                font-size: 13px;
            }

            .apply-btn {
                padding: 8px 20px;
                background: #4caf50;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }

            .apply-btn:hover {
                background: #45a049;
            }

            .range-info {
                display: flex;
                justify-content: space-between;
                color: #888;
                font-size: 13px;
                margin-top: 10px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Server Performance Monitor</h1>
            <p class="subtitle">
                Real-time performance metrics and system monitoring
            </p>

            <!-- Time Range Selector -->
            <div class="time-range-selector">
                <div class="time-range-presets">
                    <button class="time-btn" data-range="1m">1 Min</button>
                    <button class="time-btn" data-range="5m">5 Min</button>
                    <button class="time-btn" data-range="1h">1 Hour</button>
                    <button class="time-btn" data-range="12h">12 Hours</button>
                    <button class="time-btn active" data-range="24h">
                        24 Hours
                    </button>
                    <button class="time-btn" data-range="48h">48 Hours</button>
                    <button class="time-btn" data-range="custom">
                        Custom Range
                    </button>
                </div>
                <div
                    class="custom-range-picker"
                    id="customRangePicker"
                    style="display: none"
                >
                    <label
                        >From: <input type="datetime-local" id="startTime"
                    /></label>
                    <label
                        >To: <input type="datetime-local" id="endTime"
                    /></label>
                    <button class="apply-btn" id="applyCustomRange">
                        Apply
                    </button>
                </div>
                <div class="range-info">
                    <span id="rangeDisplay">Showing: Last 24 hours</span>
                    <span id="dataPoints"></span>
                </div>
            </div>

            <!-- Key Metrics Grid -->
            <div class="metrics-grid">
                <!-- Game Loop Performance -->
                <div class="metric-card">
                    <h2>Game Loop</h2>
                    <div class="metric-value" id="tick-time">0.00</div>
                    <div class="metric-label">Avg Tick Time (ms)</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Ticks/Sec</span>
                        <span class="metric-stat" id="ticks-per-sec">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Max Tick</span>
                        <span class="metric-stat" id="max-tick-time"
                            >0.00ms</span
                        >
                    </div>
                </div>

                <!-- System Resources -->
                <div class="metric-card">
                    <h2>System Resources</h2>
                    <div class="metric-value" id="memory-usage">0</div>
                    <div class="metric-label">Memory Usage (MB)</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">CPU Usage</span>
                        <span class="metric-stat" id="cpu-usage">0%</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Uptime</span>
                        <span class="metric-stat" id="uptime">0s</span>
                    </div>
                </div>

                <!-- Game State -->
                <div class="metric-card">
                    <h2>Game State</h2>
                    <div class="metric-value" id="total-players">0</div>
                    <div class="metric-label">Total Players</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Humans</span>
                        <span class="metric-stat" id="human-players">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Bots</span>
                        <span class="metric-stat" id="bot-count">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Projectiles</span>
                        <span class="metric-stat" id="projectile-count">0</span>
                    </div>
                </div>

                <!-- Network -->
                <div class="metric-card">
                    <h2>Network</h2>
                    <div class="metric-value" id="messages-per-sec">0</div>
                    <div class="metric-label">Messages/Sec</div>
                    <hr
                        style="
                            border: 0;
                            border-top: 1px solid #2a3f5f;
                            margin: 15px 0;
                        "
                    />
                    <div class="metric-row">
                        <span class="metric-name">Connections</span>
                        <span class="metric-stat" id="active-connections"
                            >0</span
                        >
                    </div>
                    <div class="metric-row">
                        <span class="metric-name">Bytes/Sec</span>
                        <span class="metric-stat" id="bytes-per-sec">0</span>
                    </div>
                </div>
            </div>

            <!-- Charts -->
            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Tick Time History
                </h3>
                <canvas id="tick-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Memory Usage Over
                    Time
                </h3>
                <canvas id="memory-chart"></canvas>
            </div>

            <div class="chart-container">
                <h3>
                    <span class="status-indicator good"></span>Player Count Over
                    Time
                </h3>
                <canvas id="player-chart"></canvas>
            </div>

            <!-- API Endpoints Table -->
            <div class="endpoint-table">
                <h3>API Endpoint Performance</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Endpoint</th>
                            <th>Requests</th>
                            <th>Avg Time (ms)</th>
                            <th>Errors</th>
                        </tr>
                    </thead>
                    <tbody id="endpoint-tbody">
                        <tr>
                            <td
                                colspan="4"
                                style="text-align: center; color: #666"
                            >
                                Loading...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p class="refresh-info">Auto-refreshing every 1 second</p>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
        <script src="/socket.io/socket.io.js"></script>
        <script>
            // Chart configurations
            const chartConfig = {
                type: "line",
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                    },
                    scales: {
                        x: {
                            display: false,
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: "#2a3f5f",
                            },
                            ticks: {
                                color: "#888",
                            },
                        },
                    },
                    elements: {
                        line: {
                            tension: 0.4,
                        },
                        point: {
                            radius: 0,
                        },
                    },
                },
            };

            // Initialize charts
            const tickChart = new Chart(document.getElementById("tick-chart"), {
                ...chartConfig,
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Tick Time (ms)",
                            data: [],
                            borderColor: "#4CAF50",
                            backgroundColor: "rgba(76, 175, 80, 0.1)",
                            fill: true,
                        },
                    ],
                },
            });

            const memoryChart = new Chart(
                document.getElementById("memory-chart"),
                {
                    ...chartConfig,
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Memory (MB)",
                                data: [],
                                borderColor: "#2196F3",
                                backgroundColor: "rgba(33, 150, 243, 0.1)",
                                fill: true,
                            },
                        ],
                    },
                },
            );

            const playerChart = new Chart(
                document.getElementById("player-chart"),
                {
                    ...chartConfig,
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Players",
                                data: [],
                                borderColor: "#FF9800",
                                backgroundColor: "rgba(255, 152, 0, 0.1)",
                                fill: true,
                            },
                        ],
                    },
                },
            );

            // Utility functions
            function formatBytes(bytes) {
                if (bytes === 0) return "0 B";
                const k = 1024;
                const sizes = ["B", "KB", "MB", "GB"];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return (
                    Math.round((bytes / Math.pow(k, i)) * 100) / 100 +
                    " " +
                    sizes[i]
                );
            }

            function formatUptime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }

            function updateMetricValue(id, value, thresholds) {
                const element = document.getElementById(id);
                element.textContent = value;

                // Update color based on thresholds
                if (thresholds) {
                    element.classList.remove("warning", "danger");
                    if (
                        thresholds.danger &&
                        parseFloat(value) >= thresholds.danger
                    ) {
                        element.classList.add("danger");
                    } else if (
                        thresholds.warning &&
                        parseFloat(value) >= thresholds.warning
                    ) {
                        element.classList.add("warning");
                    }
                }
            }

            // Fetch and update metrics
            async function updateMetrics() {
                try {
                    const response = await fetch("/api/metrics");
                    const metrics = await response.json();

                    // Update game loop metrics
                    updateMetricValue(
                        "tick-time",
                        metrics.gameLoop.avgTickTime.toFixed(2),
                        {
                            warning: 16.67,
                            danger: 20,
                        },
                    );
                    updateMetricValue(
                        "ticks-per-sec",
                        metrics.gameLoop.ticksPerSecond,
                    );
                    updateMetricValue(
                        "max-tick-time",
                        metrics.gameLoop.maxTickTime.toFixed(2) + "ms",
                    );

                    // Update system metrics
                    updateMetricValue(
                        "memory-usage",
                        metrics.system.memoryUsageMB,
                        {
                            warning: 500,
                            danger: 1000,
                        },
                    );
                    updateMetricValue(
                        "cpu-usage",
                        metrics.system.cpuUsage + "%",
                        {
                            warning: 70,
                            danger: 90,
                        },
                    );
                    updateMetricValue(
                        "uptime",
                        formatUptime(metrics.system.uptime),
                    );

                    // Update game state metrics
                    updateMetricValue(
                        "total-players",
                        metrics.gameState.playerCount +
                            metrics.gameState.botCount,
                    );
                    updateMetricValue(
                        "human-players",
                        metrics.gameState.playerCount,
                    );
                    updateMetricValue("bot-count", metrics.gameState.botCount);
                    updateMetricValue(
                        "projectile-count",
                        metrics.gameState.projectileCount,
                    );

                    // Update network metrics
                    updateMetricValue(
                        "messages-per-sec",
                        metrics.network.messagesPerSecond,
                    );
                    updateMetricValue(
                        "active-connections",
                        metrics.network.activeConnections,
                    );
                    updateMetricValue(
                        "bytes-per-sec",
                        formatBytes(metrics.network.bytesPerSecond),
                    );

                    // Update charts
                    const maxDataPoints = 60;

                    // Tick time chart
                    if (tickChart.data.labels.length >= maxDataPoints) {
                        tickChart.data.labels.shift();
                        tickChart.data.datasets[0].data.shift();
                    }
                    tickChart.data.labels.push("");
                    tickChart.data.datasets[0].data.push(
                        metrics.gameLoop.avgTickTime,
                    );
                    tickChart.update("none");

                    // Memory chart
                    if (memoryChart.data.labels.length >= maxDataPoints) {
                        memoryChart.data.labels.shift();
                        memoryChart.data.datasets[0].data.shift();
                    }
                    memoryChart.data.labels.push("");
                    memoryChart.data.datasets[0].data.push(
                        metrics.system.memoryUsageMB,
                    );
                    memoryChart.update("none");

                    // Player chart
                    if (playerChart.data.labels.length >= maxDataPoints) {
                        playerChart.data.labels.shift();
                        playerChart.data.datasets[0].data.shift();
                    }
                    playerChart.data.labels.push("");
                    playerChart.data.datasets[0].data.push(
                        metrics.gameState.playerCount +
                            metrics.gameState.botCount,
                    );
                    playerChart.update("none");

                    // Update API endpoint table
                    const tbody = document.getElementById("endpoint-tbody");
                    tbody.innerHTML = "";

                    const endpoints = Object.entries(metrics.api.endpointStats);
                    if (endpoints.length === 0) {
                        tbody.innerHTML =
                            '<tr><td colspan="4" style="text-align: center; color: #666;">No API requests yet</td></tr>';
                    } else {
                        endpoints.forEach(([endpoint, stats]) => {
                            const row = document.createElement("tr");
                            row.innerHTML = `
                            <td>${endpoint}</td>
                            <td>${stats.count}</td>
                            <td>${stats.avgTime.toFixed(2)}</td>
                            <td style="color: ${stats.errors > 0 ? "#F44336" : "#4CAF50"}">${stats.errors}</td>
                        `;
                            tbody.appendChild(row);
                        });
                    }
                } catch (error) {
                    console.error("Failed to fetch metrics:", error);
                }
            }

            // Connect to WebSocket for real-time updates
            const socket = io("/performance");

            socket.on("connect", () => {
                console.log("Connected to performance metrics stream");
                document.querySelector(".subtitle").textContent =
                    "Real-time performance metrics (WebSocket connected)";
            });

            socket.on("disconnect", () => {
                console.log("Disconnected from performance metrics stream");
                document.querySelector(".subtitle").textContent =
                    "Real-time performance metrics (WebSocket disconnected)";
            });

            socket.on("metrics", (metrics) => {
                // Update game loop metrics
                updateMetricValue(
                    "tick-time",
                    metrics.gameLoop.avgTickTime.toFixed(2),
                    {
                        warning: 16.67,
                        danger: 20,
                    },
                );
                updateMetricValue(
                    "ticks-per-sec",
                    metrics.gameLoop.ticksPerSecond,
                );
                updateMetricValue(
                    "max-tick-time",
                    metrics.gameLoop.maxTickTime.toFixed(2) + "ms",
                );

                // Update system metrics
                updateMetricValue(
                    "memory-usage",
                    metrics.system.memoryUsageMB,
                    {
                        warning: 500,
                        danger: 1000,
                    },
                );
                updateMetricValue("cpu-usage", metrics.system.cpuUsage + "%", {
                    warning: 70,
                    danger: 90,
                });
                updateMetricValue(
                    "uptime",
                    formatUptime(metrics.system.uptime),
                );

                // Update game state metrics
                updateMetricValue(
                    "total-players",
                    metrics.gameState.playerCount + metrics.gameState.botCount,
                );
                updateMetricValue(
                    "human-players",
                    metrics.gameState.playerCount,
                );
                updateMetricValue("bot-count", metrics.gameState.botCount);
                updateMetricValue(
                    "projectile-count",
                    metrics.gameState.projectileCount,
                );

                // Update network metrics
                updateMetricValue(
                    "messages-per-sec",
                    metrics.network.messagesPerSecond,
                );
                updateMetricValue(
                    "active-connections",
                    metrics.network.activeConnections,
                );
                updateMetricValue(
                    "bytes-per-sec",
                    formatBytes(metrics.network.bytesPerSecond),
                );

                // Update charts
                const maxDataPoints = 60;

                // Tick time chart
                if (tickChart.data.labels.length >= maxDataPoints) {
                    tickChart.data.labels.shift();
                    tickChart.data.datasets[0].data.shift();
                }
                tickChart.data.labels.push("");
                tickChart.data.datasets[0].data.push(
                    metrics.gameLoop.avgTickTime,
                );
                tickChart.update("none");

                // Memory chart
                if (memoryChart.data.labels.length >= maxDataPoints) {
                    memoryChart.data.labels.shift();
                    memoryChart.data.datasets[0].data.shift();
                }
                memoryChart.data.labels.push("");
                memoryChart.data.datasets[0].data.push(
                    metrics.system.memoryUsageMB,
                );
                memoryChart.update("none");

                // Player chart
                if (playerChart.data.labels.length >= maxDataPoints) {
                    playerChart.data.labels.shift();
                    playerChart.data.datasets[0].data.shift();
                }
                playerChart.data.labels.push("");
                playerChart.data.datasets[0].data.push(
                    metrics.gameState.playerCount + metrics.gameState.botCount,
                );
                playerChart.update("none");

                // Update API endpoint table
                const tbody = document.getElementById("endpoint-tbody");
                tbody.innerHTML = "";

                const endpoints = Object.entries(metrics.api.endpointStats);
                if (endpoints.length === 0) {
                    tbody.innerHTML =
                        '<tr><td colspan="4" style="text-align: center; color: #666;">No API requests yet</td></tr>';
                } else {
                    endpoints.forEach(([endpoint, stats]) => {
                        const row = document.createElement("tr");
                        row.innerHTML = `
                        <td>${endpoint}</td>
                        <td>${stats.count}</td>
                        <td>${stats.avgTime.toFixed(2)}</td>
                        <td style="color: ${stats.errors > 0 ? "#F44336" : "#4CAF50"}">${stats.errors}</td>
                    `;
                        tbody.appendChild(row);
                    });
                }
            });

            // Fallback to polling if WebSocket fails
            socket.on("connect_error", () => {
                console.log("WebSocket failed, falling back to polling");
                setInterval(updateMetrics, 1000);
            });

            // Time Range Selection
            let currentTimeRange = "24h";
            let customStart = null;
            let customEnd = null;

            // Convert range string to milliseconds
            function rangeToMs(range) {
                const units = {
                    "1m": 1 * 60 * 1000,
                    "5m": 5 * 60 * 1000,
                    "1h": 1 * 60 * 60 * 1000,
                    "12h": 12 * 60 * 60 * 1000,
                    "24h": 24 * 60 * 60 * 1000,
                    "48h": 48 * 60 * 60 * 1000,
                };
                return units[range] || units["24h"];
            }

            // Update historical data
            async function updateHistoricalData() {
                try {
                    let url;
                    if (
                        currentTimeRange === "custom" &&
                        customStart &&
                        customEnd
                    ) {
                        // Custom range query
                        const start = new Date(customStart).getTime();
                        const end = new Date(customEnd).getTime();
                        url = `/api/metrics/history?start=${start}&end=${end}`;
                    } else {
                        // Preset range
                        const hours =
                            rangeToMs(currentTimeRange) / (60 * 60 * 1000);
                        url = `/api/metrics/history?hours=${hours}`;
                    }

                    const response = await fetch(url);
                    const result = await response.json();

                    // Update data points display
                    document.getElementById("dataPoints").textContent =
                        `${result.count} data points`;

                    console.log(
                        `Loaded ${result.count} historical data points`,
                    );

                    // TODO: Update graphs with historical data
                    // This is where we'd update charts/graphs
                } catch (error) {
                    console.error("Failed to load historical data:", error);
                }
            }

            // Handle time range button clicks
            document.querySelectorAll(".time-btn").forEach((btn) => {
                btn.addEventListener("click", function () {
                    // Remove active class from all buttons
                    document
                        .querySelectorAll(".time-btn")
                        .forEach((b) => b.classList.remove("active"));

                    // Add active class to clicked button
                    this.classList.add("active");

                    const range = this.getAttribute("data-range");
                    currentTimeRange = range;

                    // Show/hide custom range picker
                    const customPicker =
                        document.getElementById("customRangePicker");
                    if (range === "custom") {
                        customPicker.style.display = "flex";

                        // Set default values to last 24 hours
                        const now = new Date();
                        const yesterday = new Date(
                            now.getTime() - 24 * 60 * 60 * 1000,
                        );

                        document.getElementById("endTime").value = now
                            .toISOString()
                            .slice(0, 16);
                        document.getElementById("startTime").value = yesterday
                            .toISOString()
                            .slice(0, 16);
                    } else {
                        customPicker.style.display = "none";

                        // Update range display
                        const rangeText = {
                            "1m": "Last 1 minute",
                            "5m": "Last 5 minutes",
                            "1h": "Last 1 hour",
                            "12h": "Last 12 hours",
                            "24h": "Last 24 hours",
                            "48h": "Last 48 hours",
                        }[range];

                        document.getElementById("rangeDisplay").textContent =
                            `Showing: ${rangeText}`;

                        // Load historical data
                        updateHistoricalData();
                    }
                });
            });

            // Handle custom range apply button
            document
                .getElementById("applyCustomRange")
                .addEventListener("click", function () {
                    customStart = document.getElementById("startTime").value;
                    customEnd = document.getElementById("endTime").value;

                    if (!customStart || !customEnd) {
                        alert("Please select both start and end times");
                        return;
                    }

                    const start = new Date(customStart);
                    const end = new Date(customEnd);

                    if (start >= end) {
                        alert("Start time must be before end time");
                        return;
                    }

                    document.getElementById("rangeDisplay").textContent =
                        `Showing: ${start.toLocaleString()} to ${end.toLocaleString()}`;

                    // Load historical data for custom range
                    updateHistoricalData();
                });

            // Load initial historical data
            updateHistoricalData();
        </script>
    </body>
</html>
