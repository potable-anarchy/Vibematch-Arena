<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Performance Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 32px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #1a1f2e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a3f5f;
        }

        .metric-card h2 {
            font-size: 16px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-value {
            font-size: 36px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 8px;
        }

        .metric-value.warning {
            color: #FFC107;
        }

        .metric-value.danger {
            color: #F44336;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .metric-row:last-child {
            margin-bottom: 0;
        }

        .metric-name {
            font-size: 14px;
            color: #aaa;
        }

        .metric-stat {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }

        .chart-container {
            background: #1a1f2e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a3f5f;
            height: 300px;
        }

        .chart-container h3 {
            font-size: 18px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        canvas {
            width: 100% !important;
            height: calc(100% - 40px) !important;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-indicator.good {
            background-color: #4CAF50;
        }

        .status-indicator.warning {
            background-color: #FFC107;
        }

        .status-indicator.danger {
            background-color: #F44336;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .endpoint-table {
            background: #1a1f2e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a3f5f;
        }

        .endpoint-table h3 {
            font-size: 18px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2a3f5f;
        }

        th {
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 12px;
        }

        td {
            color: #e0e0e0;
        }

        tr:hover {
            background: #222938;
        }

        .refresh-info {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Server Performance Monitor</h1>
        <p class="subtitle">Real-time performance metrics and system monitoring</p>

        <!-- Key Metrics Grid -->
        <div class="metrics-grid">
            <!-- Game Loop Performance -->
            <div class="metric-card">
                <h2>Game Loop</h2>
                <div class="metric-value" id="tick-time">0.00</div>
                <div class="metric-label">Avg Tick Time (ms)</div>
                <hr style="border: 0; border-top: 1px solid #2a3f5f; margin: 15px 0;">
                <div class="metric-row">
                    <span class="metric-name">Ticks/Sec</span>
                    <span class="metric-stat" id="ticks-per-sec">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Max Tick</span>
                    <span class="metric-stat" id="max-tick-time">0.00ms</span>
                </div>
            </div>

            <!-- System Resources -->
            <div class="metric-card">
                <h2>System Resources</h2>
                <div class="metric-value" id="memory-usage">0</div>
                <div class="metric-label">Memory Usage (MB)</div>
                <hr style="border: 0; border-top: 1px solid #2a3f5f; margin: 15px 0;">
                <div class="metric-row">
                    <span class="metric-name">CPU Usage</span>
                    <span class="metric-stat" id="cpu-usage">0%</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Uptime</span>
                    <span class="metric-stat" id="uptime">0s</span>
                </div>
            </div>

            <!-- Game State -->
            <div class="metric-card">
                <h2>Game State</h2>
                <div class="metric-value" id="total-players">0</div>
                <div class="metric-label">Total Players</div>
                <hr style="border: 0; border-top: 1px solid #2a3f5f; margin: 15px 0;">
                <div class="metric-row">
                    <span class="metric-name">Humans</span>
                    <span class="metric-stat" id="human-players">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Bots</span>
                    <span class="metric-stat" id="bot-count">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Projectiles</span>
                    <span class="metric-stat" id="projectile-count">0</span>
                </div>
            </div>

            <!-- Network -->
            <div class="metric-card">
                <h2>Network</h2>
                <div class="metric-value" id="messages-per-sec">0</div>
                <div class="metric-label">Messages/Sec</div>
                <hr style="border: 0; border-top: 1px solid #2a3f5f; margin: 15px 0;">
                <div class="metric-row">
                    <span class="metric-name">Connections</span>
                    <span class="metric-stat" id="active-connections">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Bytes/Sec</span>
                    <span class="metric-stat" id="bytes-per-sec">0</span>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="chart-container">
            <h3><span class="status-indicator good"></span>Tick Time History</h3>
            <canvas id="tick-chart"></canvas>
        </div>

        <div class="chart-container">
            <h3><span class="status-indicator good"></span>Memory Usage Over Time</h3>
            <canvas id="memory-chart"></canvas>
        </div>

        <div class="chart-container">
            <h3><span class="status-indicator good"></span>Player Count Over Time</h3>
            <canvas id="player-chart"></canvas>
        </div>

        <!-- API Endpoints Table -->
        <div class="endpoint-table">
            <h3>API Endpoint Performance</h3>
            <table>
                <thead>
                    <tr>
                        <th>Endpoint</th>
                        <th>Requests</th>
                        <th>Avg Time (ms)</th>
                        <th>Errors</th>
                    </tr>
                </thead>
                <tbody id="endpoint-tbody">
                    <tr>
                        <td colspan="4" style="text-align: center; color: #666;">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <p class="refresh-info">Auto-refreshing every 1 second</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Chart configurations
        const chartConfig = {
            type: 'line',
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: '#2a3f5f'
                        },
                        ticks: {
                            color: '#888'
                        }
                    }
                },
                elements: {
                    line: {
                        tension: 0.4
                    },
                    point: {
                        radius: 0
                    }
                }
            }
        };

        // Initialize charts
        const tickChart = new Chart(document.getElementById('tick-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [{
                    label: 'Tick Time (ms)',
                    data: [],
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    fill: true
                }]
            }
        });

        const memoryChart = new Chart(document.getElementById('memory-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [{
                    label: 'Memory (MB)',
                    data: [],
                    borderColor: '#2196F3',
                    backgroundColor: 'rgba(33, 150, 243, 0.1)',
                    fill: true
                }]
            }
        });

        const playerChart = new Chart(document.getElementById('player-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [{
                    label: 'Players',
                    data: [],
                    borderColor: '#FF9800',
                    backgroundColor: 'rgba(255, 152, 0, 0.1)',
                    fill: true
                }]
            }
        });

        // Utility functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }

        function updateMetricValue(id, value, thresholds) {
            const element = document.getElementById(id);
            element.textContent = value;

            // Update color based on thresholds
            if (thresholds) {
                element.classList.remove('warning', 'danger');
                if (thresholds.danger && parseFloat(value) >= thresholds.danger) {
                    element.classList.add('danger');
                } else if (thresholds.warning && parseFloat(value) >= thresholds.warning) {
                    element.classList.add('warning');
                }
            }
        }

        // Fetch and update metrics
        async function updateMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const metrics = await response.json();

                // Update game loop metrics
                updateMetricValue('tick-time', metrics.gameLoop.avgTickTime.toFixed(2), {
                    warning: 16.67,
                    danger: 20
                });
                updateMetricValue('ticks-per-sec', metrics.gameLoop.ticksPerSecond);
                updateMetricValue('max-tick-time', metrics.gameLoop.maxTickTime.toFixed(2) + 'ms');

                // Update system metrics
                updateMetricValue('memory-usage', metrics.system.memoryUsageMB, {
                    warning: 500,
                    danger: 1000
                });
                updateMetricValue('cpu-usage', metrics.system.cpuUsage + '%', {
                    warning: 70,
                    danger: 90
                });
                updateMetricValue('uptime', formatUptime(metrics.system.uptime));

                // Update game state metrics
                updateMetricValue('total-players', metrics.gameState.playerCount + metrics.gameState.botCount);
                updateMetricValue('human-players', metrics.gameState.playerCount);
                updateMetricValue('bot-count', metrics.gameState.botCount);
                updateMetricValue('projectile-count', metrics.gameState.projectileCount);

                // Update network metrics
                updateMetricValue('messages-per-sec', metrics.network.messagesPerSecond);
                updateMetricValue('active-connections', metrics.network.activeConnections);
                updateMetricValue('bytes-per-sec', formatBytes(metrics.network.bytesPerSecond));

                // Update charts
                const maxDataPoints = 60;

                // Tick time chart
                if (tickChart.data.labels.length >= maxDataPoints) {
                    tickChart.data.labels.shift();
                    tickChart.data.datasets[0].data.shift();
                }
                tickChart.data.labels.push('');
                tickChart.data.datasets[0].data.push(metrics.gameLoop.avgTickTime);
                tickChart.update('none');

                // Memory chart
                if (memoryChart.data.labels.length >= maxDataPoints) {
                    memoryChart.data.labels.shift();
                    memoryChart.data.datasets[0].data.shift();
                }
                memoryChart.data.labels.push('');
                memoryChart.data.datasets[0].data.push(metrics.system.memoryUsageMB);
                memoryChart.update('none');

                // Player chart
                if (playerChart.data.labels.length >= maxDataPoints) {
                    playerChart.data.labels.shift();
                    playerChart.data.datasets[0].data.shift();
                }
                playerChart.data.labels.push('');
                playerChart.data.datasets[0].data.push(metrics.gameState.playerCount + metrics.gameState.botCount);
                playerChart.update('none');

                // Update API endpoint table
                const tbody = document.getElementById('endpoint-tbody');
                tbody.innerHTML = '';

                const endpoints = Object.entries(metrics.api.endpointStats);
                if (endpoints.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666;">No API requests yet</td></tr>';
                } else {
                    endpoints.forEach(([endpoint, stats]) => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${endpoint}</td>
                            <td>${stats.count}</td>
                            <td>${stats.avgTime.toFixed(2)}</td>
                            <td style="color: ${stats.errors > 0 ? '#F44336' : '#4CAF50'}">${stats.errors}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
            } catch (error) {
                console.error('Failed to fetch metrics:', error);
            }
        }

        // Connect to WebSocket for real-time updates
        const socket = io('/performance');

        socket.on('connect', () => {
            console.log('Connected to performance metrics stream');
            document.querySelector('.subtitle').textContent = 'Real-time performance metrics (WebSocket connected)';
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from performance metrics stream');
            document.querySelector('.subtitle').textContent = 'Real-time performance metrics (WebSocket disconnected)';
        });

        socket.on('metrics', (metrics) => {
            // Update game loop metrics
            updateMetricValue('tick-time', metrics.gameLoop.avgTickTime.toFixed(2), {
                warning: 16.67,
                danger: 20
            });
            updateMetricValue('ticks-per-sec', metrics.gameLoop.ticksPerSecond);
            updateMetricValue('max-tick-time', metrics.gameLoop.maxTickTime.toFixed(2) + 'ms');

            // Update system metrics
            updateMetricValue('memory-usage', metrics.system.memoryUsageMB, {
                warning: 500,
                danger: 1000
            });
            updateMetricValue('cpu-usage', metrics.system.cpuUsage + '%', {
                warning: 70,
                danger: 90
            });
            updateMetricValue('uptime', formatUptime(metrics.system.uptime));

            // Update game state metrics
            updateMetricValue('total-players', metrics.gameState.playerCount + metrics.gameState.botCount);
            updateMetricValue('human-players', metrics.gameState.playerCount);
            updateMetricValue('bot-count', metrics.gameState.botCount);
            updateMetricValue('projectile-count', metrics.gameState.projectileCount);

            // Update network metrics
            updateMetricValue('messages-per-sec', metrics.network.messagesPerSecond);
            updateMetricValue('active-connections', metrics.network.activeConnections);
            updateMetricValue('bytes-per-sec', formatBytes(metrics.network.bytesPerSecond));

            // Update charts
            const maxDataPoints = 60;

            // Tick time chart
            if (tickChart.data.labels.length >= maxDataPoints) {
                tickChart.data.labels.shift();
                tickChart.data.datasets[0].data.shift();
            }
            tickChart.data.labels.push('');
            tickChart.data.datasets[0].data.push(metrics.gameLoop.avgTickTime);
            tickChart.update('none');

            // Memory chart
            if (memoryChart.data.labels.length >= maxDataPoints) {
                memoryChart.data.labels.shift();
                memoryChart.data.datasets[0].data.shift();
            }
            memoryChart.data.labels.push('');
            memoryChart.data.datasets[0].data.push(metrics.system.memoryUsageMB);
            memoryChart.update('none');

            // Player chart
            if (playerChart.data.labels.length >= maxDataPoints) {
                playerChart.data.labels.shift();
                playerChart.data.datasets[0].data.shift();
            }
            playerChart.data.labels.push('');
            playerChart.data.datasets[0].data.push(metrics.gameState.playerCount + metrics.gameState.botCount);
            playerChart.update('none');

            // Update API endpoint table
            const tbody = document.getElementById('endpoint-tbody');
            tbody.innerHTML = '';

            const endpoints = Object.entries(metrics.api.endpointStats);
            if (endpoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666;">No API requests yet</td></tr>';
            } else {
                endpoints.forEach(([endpoint, stats]) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${endpoint}</td>
                        <td>${stats.count}</td>
                        <td>${stats.avgTime.toFixed(2)}</td>
                        <td style="color: ${stats.errors > 0 ? '#F44336' : '#4CAF50'}">${stats.errors}</td>
                    `;
                    tbody.appendChild(row);
                });
            }
        });

        // Fallback to polling if WebSocket fails
        socket.on('connect_error', () => {
            console.log('WebSocket failed, falling back to polling');
            setInterval(updateMetrics, 1000);
        });
    </script>
</body>
</html>
